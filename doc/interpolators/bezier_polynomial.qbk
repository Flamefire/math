[/
  Copyright 2021 Nick Thompson

  Distributed under the Boost Software License, Version 1.0.
  (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt).
]

[section:bezier_polynomial Bezier Polynomials]

[heading Synopsis]

``
#include <boost/math/interpolators/bezier_polynomials.hpp>

namespace boost::math::interpolators {

    template<RandomAccessContainer>
    class bezier_polynomial
    {
    public:
        using Point = typename RandomAccessContainer::value_type;
        using Real = typename Point::value_type;

        bezier_polynomial(RandomAccessContainer&& control_points);

        inline Point operator()(Real t) const;
    };

}}
``

[heading Description]

B[eacute]zier polynomials are curves smooth curves which approximate a set of control points.
They are commonly used in computer-aided geometric design.
A basic usage is demonstrated below:

    std::vector<std::array<Real, 3>> control_points(4);
    control_points[0] = {0,0,0};
    control_points[1] = {1,0,0};
    control_points[2] = {0,1,0};
    control_points[3] = {0,0,1};
    auto bp = bezier_polynomial(std::move(control_points));
    // Interpolate at t = 0.1:
    auto point = bp(0.1);

The support of the interpolant is [0,1], and an error message will be written if attempting to evaluate the polynomial outside of these bounds.
At least two points must be passed; creating a polynomial of degree 1.


[heading Caveats]

Do not confuse the Bezier polynomial with a Bezier spline.
A Bezier spline has a fixed polynomial order and subdivides the curve into low-order polynomial segments.
/This is not a spline!/
Passing /n/ control points to the `bezier_polynomial` class creates a polynomial of degree n-1, whereas a Bezier spline has a fixed order independent of the number of control points.

Requires C++17.


[heading Performance]

The following performance numbers were generated for evaluating the Bezier-polynomial.
The evaluation of the interpolant is [bigo](/N/^2), as expected from de Casteljau's algorithm.


    Run on 2700 MHz CPU
    CPU Caches:
      L1 Data 32K (x2)
      L1 Instruction 32K (x2)
      L2 Unified 262K (x2)
      L3 Unified 3145K (x1)
    ---------------------------------------------------------
    Benchmark                              Time           CPU
    ---------------------------------------------------------
    BezierPolynomial<double>/2        71.7 ns         71.7 ns
    BezierPolynomial<double>/3        76.7 ns         76.7 ns
    BezierPolynomial<double>/4        81.7 ns         81.6 ns
    BezierPolynomial<double>/5        89.1 ns         89.0 ns
    BezierPolynomial<double>/6        91.8 ns         91.7 ns
    BezierPolynomial<double>/7        96.0 ns         95.9 ns
    BezierPolynomial<double>/8         105 ns          105 ns
    BezierPolynomial<double>/9         113 ns          113 ns
    BezierPolynomial<double>/10        127 ns          127 ns
    BezierPolynomial<double>/11        135 ns          135 ns
    BezierPolynomial<double>/12        194 ns          194 ns
    BezierPolynomial<double>/13        209 ns          209 ns
    BezierPolynomial<double>/14        222 ns          222 ns
    BezierPolynomial<double>/15        231 ns          230 ns
    BezierPolynomial<double>/16        264 ns          263 ns
    BezierPolynomial<double>/17        269 ns          268 ns
    BezierPolynomial<double>/18        298 ns          297 ns
    BezierPolynomial<double>/19        286 ns          286 ns


[heading Point types]

The `Point` type must satisfy certain conceptual requirements which are discussed in the documentation of the Catmull-Rom curve.
However, we reiterate them here:

    template<class Real>
    class mypoint3d
    {
    public:
        // Must define a value_type:
        typedef Real value_type;

        // Regular constructor--need not be of this form.
        mypoint3d(Real x, Real y, Real z) {m_vec[0] = x; m_vec[1] = y; m_vec[2] = z; }

        // Must define a default constructor:
        mypoint3d() {}

        // Must define array access:
        Real operator[](size_t i) const
        {
            return m_vec[i];
        }

        // Must define array element assignment:
        Real& operator[](size_t i)
        {
            return m_vec[i];
        }

    private:
        std::array<Real, 3> m_vec;
    };

These conditions are satisfied by both `std::array` and `std::vector`.


[heading References]

* Rainer Kress, ['Numerical Analysis], Springer, 1998
* David Salomon, ['Curves and Surfaces for Computer Graphics], Springer, 2005

[endsect] [/section:bezier_polynomials Bezier Polynomials]
